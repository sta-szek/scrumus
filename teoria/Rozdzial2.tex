\chapter{Analiza biznesowa problemu i założenia projektowe}

\section{Role i użytkownicy systemu}
W projektowanym systemie występują cztery rodzaje użytkowników:

\begin{enumerate}
	\item administrator - posiada on największe uprawnienia w systemie,
	\item właściciel produktu - odzwierciela rolę właściciela produktu w Scrumie,
	\item scrum master - odzwierciela rolę scrum mastera w Scrumie,
	\item deweloper - posiada najmniejsze uprawnienia, jest częścią zespołu deweloperskiego.
\end{enumerate} 

Na tym etapie warto wspomnieć, że każdy użytkownik jest jest deweloperem. Każdy projekt może mieć tylko jednego właściciela produktu, a każdy z nich może być product ownerem tylko raz. Dodatkowo zespół deweloperski ma przydzielonego tylko jednego scrum mastera, przy czym scrum master może być przypisany do wielu zespołów jednocześnie.

\section{Wymagania funkcjonalne}
Prezentowany przeze mnie system ma pewne założenia oraz wymagania. W tym rozdziale zajmę się opisem wymagań funkcjonalnych. 

We wcześniejszym akapicie zostały omówione role w systemie. Każda z tych ról ma pewne uprawnienia lub restrykcje. Każda taka cecha zostanie przedstawiona jako wymaganie funkcjonalne prezentowanego systemy.

Jednym ze sposobów na prowadzenie dokumentacji projektu, jak i zbioru wymagań jest utrzymywanie rejestru historyjek użytkownika. Historyjki użytkownika są częścią zwinnych metody prowadzenia projektu. Jako że wytwarzanemu systemowi towarzyszy metodyka Scrum, nie mogło tutaj zabraknąć tego elementu.

\begin{italicquote}
	Historyjka jest jednostką funkcjonalności w projektach XP. Pokazujemy postęp prac, dostarczając przetestowany i zintegrowany kod, który składa się na implementację danej historyjki. Historyjka powinna być zrozumiała i wartościowa dla klientów, testowalna przez programistów i na tyle mała, żeby programiści mogli zaimplementować sześć historyjek w takcie jednej iteracji\footnote{K. Beck, M. Fowler, \textit{Planning Extreme Programming}, Addison-Wesley, Boston 2000, s.42}.
\end{italicquote}

Historyjki mogą mieć wiele wzorców. W tej pracy są stosowane dwa z nich:
\begin{itemize}
	\item Jako \textit{\textless typ użytkownika\textgreater} mogę \textit{\textless nazwa zadania\textgreater}.
	\item Jako \textit{\textless typ użytkownika\textgreater} mogę \textit{\textless nazwa zadania\textgreater} w celu \textit{\textless cel\textgreater}\cite{SCRUM}
\end{itemize} 


\textbf{Administrator}
\begin{enumerate}	
	\item jako administrator mogę tworzyć nowych użytkowników w celu dodania ich do systemu,
	\item jako administrator mogę usuwać użytkowników z systemu z wyjątkiem siebie samego,
	\item jako administrator mogę dodawać użytkowników do zespołu w celu modyfikacji zespołu,
	\item jako administrator mogę usuwać użytkowników z zespołu w celu modyfikacji zespołu,
	\item jako administrator mogę nadać uprawnienia administratora dowolnemu użytkownikowi,
	\item jako administrator mogę odebrać uprawnienia administratora dowolnemu administratorowi,
	\item jako administrator mogę przypisać właściciela produktu do projektu,
	\item jako administrator mogę usunąć właściciela produktu z projektu,
	\item jako administrator mogę utworzyć projekt w celu dodania go do systemu,
	\item jako administrator mogę usunąć projekt w celu usunięcia z systemu oraz powiązanych z nim elementów t.j. sprint, story, backlog oraz inne. Operacja usuwania odbywa się kaskadowo,
	\item jako administrator mogę modyfikować projekt,
	\item jako administrator mogę tworzyć nowe zespoły w celu dodania ich do systemu,
	\item jako administrator mogę dodawać zespoły do projektów w celu przydzielenia uprawnień,
	\item jako administrator mogę usuwać zespoły z projektów w celu odebrania uprawnień,
	\item jako administrator mogę przypisać scrum mastera do zespołu,
	\item jako administrator mogę usunąć scrum mastera z zespołu,
	\item jako administrator mogę tworzyć, usuwać oraz edytować statusy zadań,
	\item jako administrator mogę tworzyć, usuwać oraz edytować priorytety zadań,
	\item jako administrator mogę tworzyć, usuwać oraz edytować typy zadań.
\end{enumerate}		
\textbf{Product owner}
\begin{enumerate}		
	\item TODO
\end{enumerate}	
\textbf{Scrum master}
\begin{enumerate}		
	\item TODO
\end{enumerate}
\textbf{Developer}
\begin{enumerate}		
	\item jako deweloper mogę tworzyć zadania,
	\item jako deweloper mogę usuwać zadania,
	\item jako deweloper mogę dodawać komentarze do zadań,
	\item jako deweloper mogę dodawać komentarze do retrospektyw,
	\item jako deweloper mogę edytować swój profil,
	\item jako deweloper mogę zmienić swoje hasło,
	\item jako deweloper mogę przeglądać profile innych użytkowników,
	\item jako deweloper mogę przeglądać wszystkie projekty, do których jestem przypisany,
	\item jako deweloper mogę przypisać zadanie do dowolnego użytkownika,
	
\end{enumerate}

\section{Wymagania niefunkcjonalne}
Kolejnym zagadnieniem, które zostanie poruszone w tym rozdziale będą wymagania niefunkcjonalne. Do analizy zostanie wykorzystana metoda FURPS. Oto pełny spis wymagań niefunkcjonalnych systemu:
\begin{enumerate}
	\item \textbf{F}unctionality - funkcjonalność, system powinien:
		\begin{itemize}
			\item spełniać wszystkie wymagania funkcjonalne,
			\item mieć możliwość administracji poprzez panel administracyjny,
			\item posiadać audyt w postaci logów systemu,
			\item być łatwo rozszerzalny.
		\end{itemize}
	\item \textbf{U}sability - używalność, system powinien posiadać następujące cechy:
		\begin{itemize}
			\item ergonomia - łatwość używania,
			\item look \& feel, czyli estetyczność oraz możliwość modyfikacji wyglądu,
			\item internacjonalizacja - wiele wersji językowych.
		\end{itemize}
	\item \textbf{R}eliability - niezawodność, w której skład wchodzą:
		\begin{itemize}
			\item dostępność, czyli czas pomiędzy awariami,
			\item odzyskiwalność - ile czasu zajmie ponowne uruchomienie systemu.
		\end{itemize}
	\item \textbf{P}erformance - wydajność, system powinien:
		\begin{itemize}
			\item być przepustowy ,
			\item mieć dużą responsywność,
			\item działać szybko.
		\end{itemize}
	\item \textbf{S}supportability - wsparcie, do którego należy:
		\begin{itemize}
			\item prostota w instalacji,
			\item łatwość konfiguracji,
			\item adaptowalność, czyli możliwość zaadoptowania systemu do innych warunków,
			\item testowalność, czyli testy jednostkowe oraz integracyjne.
		\end{itemize}
\end{enumerate}

\section{Użyte technologie i narzędzia}
Przy implementacji tego systemu wykorzystano wiele gotowych rozwiązań, które bez wątpienia podniosły wydajność pracy poprzez automatyczne budowanie, czy wdrażanie projektu na serwer. Również jakoś aplikacji utrzymuje się na bardzo dobrym poziomie dzięki wielu testom jednostkowym, integracyjnym i w końcu testom użytkownika końcowego. 

Dodatkowo przy implementowaniu systemu zostały wykorzystane narzędzia, które oferuje Student Developer Pack. Znalazł się tam między innymi system GitHub w wersji Micro z możliwością prowadzenia prywatnych repozytoriów.\footnote{Projekt Student Developer Pack dotyczy wyłącznie studentów. Więcej informacji można znaleźć pod adresem \url{https://education.github.com/pack/offers}}

\subsection{Testowanie}
Jak wiadomo w dzisiejszych czasach aplikacje, które nie posiadają testów, jak i również te, które testów nie przechodzą, nie mają prawa znaleźć się na serwerze produkcyjnym. Co prawda przy projektowaniu mojej aplikacji serwer produkcyjny jak i testowy stanowił jedność, jednak bez testów obyć się nie mogło.

\subsubsection{JUnit}
JUnit jest frameworkiem, który umożliwia pisanie testów jednostkowych. Stosuje się go do aplikacji napisanych w języku Java. Jego działanie sprawia, że uruchomienie testów trwa parę sekund, dzięki czemu programista może je uruchamiać na bieżąco, przez co jakoś kodu jest stale monitorowana. Framework ten jest doskonale zintegrowany z systemami budowania projektów takimi jak Gradle czy Maven. 

\subsection{Arquillian}
Arquillian jest kolejnym frameworkiem do testowania, tym razem jednak integracyjnego. Posiada on wsparcie dla wielu kontenerów aplikacji JEE, co czyni go pionierem pod tym względem. Dzięki jego mechanizmom możliwe jest uruchomienie testów bez konieczności posiadania serwera aplikacji, co znacznie przyśpiesza wykonywanie testów integracyjnych. Istnieje również możliwość uruchamiania testów na zdalnym serwerze i to właśnie tą ścieżkę wybrałem, ze względu na większe możliwości testowania oraz to, że aplikacja jest uruchamiana na żywym środowisku, przez co umożliwia to sprawdzenia zachowania aplikacji dokładnie na takim serwerze, na jakim będzie uruchomiona wersja produkcyjna.

\subsection{Ciągła integracja}
Koleje narzędzia z grupy ciągłej integracji umożliwiają budowanie, testowanie oraz monitorowanie stanu projektu na każdym etapie jego powstawania. W dzisiejszych czasach każda firma, a nawet osoby prywatne, posiada takie systemy, bez których nie byłoby możliwe tak szybkie wytwarzanie aplikacji.

\subsubsection{Gradle}
Gradle jest darmowym narzędziem do budowania projektów oraz zarządzania zależnościami, przez co programista może skupić się na pracy, a wszystkimi bibliotekami oraz zadaniami jakie należy wykonać podczas budowania zajmie się Gradle. W przeciwieństwie do Maven został on stworzony przy użyciu języka Groovy, co sprawia, że nie ma rzeczy niewykonanych. Jego prostota i zarazem ogrom możliwości sprawiają, że powoli zastępuje on przestarzały framework Maven. Dzięki temu projektowi za pomocą jednej komendy skompilujemy, zbudujemy oraz uruchomimy testy naszej aplikacji. Gradle został przyswojony przez prawie każdy system budowania projektów, przez co był oczywistym wyborem przy planowaniu projektu.

\subsubsection{GitHub}
GitHub jest serwisem, który umożliwia prowadzenie projektów z użyciem systemu kontroli wersji - Git. Git jest rozproszonym systemem kontroli wersji. Umożliwia on prowadzenie projektu w sposób przejrzysty i efektowny. Każda nasza zmiana jest rejestrowana w tym systemie z możliwością jej przywrócenia bądź też cofnięcia, przez co nie musimy obawiać się, że coś nam ucieknie. Dzięki pakietowi Student Developer Pack, otrzymałem rozszerzone konto GitHub, które zawiera do 5 prywatnych repozytoriów. Narzędzie to pozwoliło mi utrzymać kod w prywatności przed światem zewnętrznym jak i również udostępnić go dla promotora.


\subsubsection{TeamCity}
TeamCity jest potężnym narzędziem do budowy projektów, którego rozwojem zajmuje się firma JetBrains. Jest on darmowy dla małych projektów i w skład tej wersji wchodzi jeden agent, który wykonuje zadania. System umożliwia budowanie oraz testowanie aplikacji, generując przy tym raporty, przez co wszystkie błędy zostaną znalezione i poprawione. Ma on świetną integrację z systemami kontroli wersji takimi jak Git czy SVN oraz innymi narzędziami tej firmy, które zostały również wykorzystane podczas prac.

\subsubsection{YouTrack}
YouTrack również jest systemem do zarządzania projektami. Jest on dedykowany ogólnie metodykom zwinnymi, między innymi Scrumowi. Używałem go podczas implementacji aplikacji, co pozwoliło mi kontrolować zadania, które należy wykonać. Aplikacja umożliwia również generowanie raportów i wykresów dot. zadań, użytkowników czy projektów. System jest również rozwijany przez firmę JetBrains, przez co jest zintegrowany z TeamCity oraz IntelliJ. Pobiera on informacje o budowach projektów z systemu TeamCity oraz umożliwia przeglądania zadań w programie IntelliJ, przez co znazcnie upraszcza pracę. Dodatkowo jest darmowy dla małych projektów (do 10 osób), przez co może być wykorzystywany przez małe firmy lub studentów.

\subsubsection{IntelliJ}
IntelliJ jest zintegrowanym środowiskiem deweloperskim na bardzo wysokim poziomie. Umożliwia on tworzenie, kompilację oraz testowanie kodu napisanego w języku Java lub innych językach, które działają na wirtualnej maszynie Javy np. Scala lub Groovy. Narzędzie to posiada szereg funkcjonalności ułatwiających i przyśpieszających programowanie. Jest ono świetnie zintegrowane z frameworkami do testowania (JUnit, Arquillian), systemami do budowania (Gradle, TeamCity), czy zarządzania (YouTrack) przez co programista może się skupić wyłącznie na jednym oknie - oknie aplikacji IntelliJ. Ten system również jest darmowy dla studentów, co stwarza świetne możliwości dla tej grupy osób.

